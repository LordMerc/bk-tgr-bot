"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStore = void 0;
const HttpRequest_1 = require("./HttpRequest");
const Globals_1 = require("../Util/Globals");
const FastLogTool_1 = require("../Tools/FastLogTool");
const RBXScriptConnection_1 = require("./RBXScriptConnection");
const events_1 = __importDefault(require("events"));
const ExecutionHelper_1 = require("../Helpers/ExecutionHelper");
const InputHelper_1 = require("../Helpers/InputHelper");
const ApiDataStoresUrlConstruction_1 = require("../Constructors/ApiDataStoresUrlConstruction");
const DataStoreService_1 = require("./Services/DataStoreService");
FastLogTool_1.LOGVARIABLE('DataStore', 0);
FastLogTool_1.DYNAMIC_FASTINTVARIABLE('DataStoreMaxValueSize', 64 * 1024);
/**
 * A GlobalDataStore exposes functions for saving and loading data for the DataStoreService.
 * See the Data Stores article for an in-depth guide on data structure,
 * management,
 * error handling,
 * etc.
 */
class DataStore {
    constructor(name, scope /*= 'global'*/, legacy) {
        /**
         * @internal
         */
        this.callbacks = new Map();
        /**
         * @internal
         */
        this.CachedKeys = new Map();
        /**
         * @internal
         */
        this.isLegacy = false;
        this.isLegacy = legacy;
        this.name = name;
        this.scope = scope;
        this.nameUrlEncodedIfNeeded = this.urlEncodeIfNeeded(name);
        this.scopeUrlEncodedIfNeeded = this.urlEncodeIfNeeded(scope);
        this.serviceUrl = ApiDataStoresUrlConstruction_1.ApiDataStoresUrlConstruction.BuildGenericPersistenceUrl(this.urlApiPath());
        FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Initialized Data Store, url: %s', this.serviceUrl);
    }
    /**
     * @internal
     */
    constructPostDataForKey(key, index = 0) {
        return this.isLegacy
            ? `&qkeys[${index}].scope=${this.scopeUrlEncodedIfNeeded.toString()}&qkeys[${index}].target=&qkeys[${index}].key=${this.urlEncodeIfNeeded(key).toString()}`
            : `&qkeys[${index}].scope=${this.scopeUrlEncodedIfNeeded.toString()}&qkeys[${index}].target=${this.urlEncodeIfNeeded(key).toString()}&qkeys[${index}].key=${this.nameUrlEncodedIfNeeded.toString()}`;
    }
    /**
     * @internal
     */
    constructGetUrl() {
        const placeId = Globals_1.Globals.PlaceID;
        return `${this.serviceUrl}getV2?placeId=${placeId}&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}`;
    }
    /**
     * @internal
     */
    constructSetUrl(key, valueLength) {
        const placeId = Globals_1.Globals.PlaceID;
        return this.isLegacy
            ? `${this.serviceUrl}set?placeId=${placeId}&key=${this.urlEncodeIfNeeded(key).toString()}&&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=&valueLength=${valueLength}`
            : `${this.serviceUrl.toString()}set?placeId=${placeId}&key=${this.nameUrlEncodedIfNeeded.toString()}&&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}&valueLength=${valueLength}`;
    }
    /**
     * @internal
     */
    constructSetIfUrl(key, valueLength, expectedValueLength) {
        const placeId = Globals_1.Globals.PlaceID;
        return this.isLegacy
            ? `${this.serviceUrl}set?placeId=${placeId}&key=${this.urlEncodeIfNeeded(key).toString()}&&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=&valueLength=${valueLength}&expectedValueLength=${expectedValueLength}`
            : `${this.serviceUrl.toString()}set?placeId=${placeId}&key=${this.nameUrlEncodedIfNeeded.toString()}&&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}&valueLength=${valueLength}&expectedValueLength=${expectedValueLength}`;
    }
    /**
     * @internal
     */
    constructIncrementUrl(key, delta) {
        const placeId = Globals_1.Globals.PlaceID;
        return this.isLegacy
            ? `${this.serviceUrl}increment?placeId=${placeId}&key=${this.urlEncodeIfNeeded(key).toString()}&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=&value=${delta}`
            : `${this.serviceUrl}increment?placeId=${placeId}&key=${this.nameUrlEncodedIfNeeded.toString()}&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}&value=${delta}`;
    }
    /**
     * @internal
     */
    constructRemoveUrl(key) {
        const placeId = Globals_1.Globals.PlaceID;
        return this.isLegacy
            ? `${this.serviceUrl}remove?placeId=${placeId}&key=${this.urlEncodeIfNeeded(key).toString()}&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=`
            : `${this.serviceUrl}remove?placeId=${placeId}&key=${this.nameUrlEncodedIfNeeded.toString()}&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}`;
    }
    /**
     * @internal
     */
    createFetchNewKeyRequest(key, request) {
        request.url = this.constructGetUrl();
        request.postData = this.constructPostDataForKey(key);
        request.owner = this;
    }
    static serializeVariant(variant) {
        let hasJsonType = true;
        let result;
        try {
            result = JSON.stringify(variant);
        }
        catch {
            hasJsonType = false;
        }
        return [hasJsonType, result];
    }
    /**
     * @internal
     */
    logLongValue(value) {
        FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Value: %s', value.substring(0, 200));
        if (value.length > 200) {
            const tail = value.substring(value.length - 200);
            FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Value end: %s', tail);
            FastLogTool_1.FASTLOG1(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Value length: %u', value.length);
        }
    }
    static deserializeVariant(webValue) {
        if (webValue instanceof Object)
            return [true, webValue];
        let result = '';
        if (webValue && webValue.length === 0)
            return [true, result];
        try {
            result = JSON.parse(webValue);
        }
        catch {
            return [false, result];
        }
        return [true, result];
    }
    /**
     * @internal
     */
    runTransformFunction(key, transformFunc) {
        return new Promise((resumeFunction, errorFunction) => {
            const request = new HttpRequest_1.HttpRequest();
            this.createFetchNewKeyRequest(key, request);
            request.requestType = DataStoreService_1.RequestType.GET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteGet(request).then((r) => {
                const [success, res] = DataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction("Can't parse response");
                let result;
                FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Running transform function, input: %s', res['data'].length === 0
                    ? undefined
                    : DataStore.deserializeVariant(res['data'][0]['Value'])[1].toString());
                try {
                    result = transformFunc(res['data'].length === 0
                        ? undefined
                        : DataStore.deserializeVariant(res['data'][0]['Value'])[1]);
                }
                catch (e) {
                    errorFunction(e);
                }
                if (result === undefined || result.size === 0 || result === null) {
                    FastLogTool_1.FASTLOG(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Transform function returned nil, update is cancelled');
                    return errorFunction('Transform function returned nil, update is cancelled');
                }
                // console.log(result);
                if (!this.checkValueIsAllowed(result))
                    return errorFunction(`${typeof result} is not allowed in ${this.getDataStoreTypeString() === 'standard' ? 'DataStore' : 'OrderedDataStore'}`);
                const [success2, newValue] = DataStore.serializeVariant(result);
                if (!success2)
                    return errorFunction(`${typeof result} is not allowed in ${this.getDataStoreTypeString() === 'standard' ? 'DataStore' : 'OrderedDataStore'}`);
                if (newValue.length > FastLogTool_1.DFInt('DataStoreMaxValueSize'))
                    return errorFunction('Value is too large');
                const expectedValue = res['data'].length === 0 ? '' : res['data'][0]['Value'];
                const postData = `value=${this.urlEncodeIfNeeded(newValue)}&expectedValue=${this.urlEncodeIfNeeded(expectedValue)}`;
                const postDataFinal = postData.toString();
                const request = new HttpRequest_1.HttpRequest();
                request.url = this.constructSetIfUrl(key, newValue.length, expectedValue.length);
                request.postData = postDataFinal.toString();
                request.owner = this;
                request.key = key;
                request.requestType = DataStoreService_1.RequestType.UPDATE_ASYNC;
                FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] SetIf on key: %s', key);
                this.logLongValue(newValue);
                FastLogTool_1.FASTLOG(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Url encoded:');
                this.logLongValue(request.postData);
                ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                    .then((r2) => {
                    const [success, res] = DataStore.deserializeVariant(r2.data);
                    if (!success)
                        return errorFunction("Can't parse response");
                    if (!res['data'])
                        return errorFunction("The response didn't contain the data, therefore a shallow fail was performed");
                    const final = DataStore.deserializeVariant(res['data'])[1];
                    if (this.callbacks.has(key)) {
                        this.callbacks.get(key)(final);
                    }
                    resumeFunction(final);
                })
                    .catch((reason) => {
                    return errorFunction(reason);
                });
            });
        });
    }
    /**
     * @internal
     */
    checkValueIsAllowed(v) {
        const [success] = DataStore.serializeVariant(v);
        return success;
    }
    /**
     * @internal
     */
    getDataStoreTypeString() {
        return 'standard';
    }
    /**
     * @internal
     */
    urlEncodeIfNeeded(input) {
        return encodeURIComponent(input);
    }
    /**
     * @internal
     */
    urlApiPath() {
        return 'persistence';
    }
    /**
     * Returns the value of the entry in the data store with the given key.
     * This function returns the value of the entry in the GlobalDataStore with the given key.
     * If the key does not exist,
     * returns undefined.
     * This function used to cache for about 4 seconds,
     * so you couldn't be sure that it returns the current value saved on the Roblox servers.
     * If this function throws an error,
     * the error message will describe the problem.
     * Note that there are also limits that will soon apply to this function.
     * @param key The key identifying the entry being retrieved from the data store.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async GetAsync(key) {
        return new Promise((resumeFunction, errorFunction) => {
            FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], `[FLog::DataStore] GetAsync on key %s`, key);
            const [success, message] = InputHelper_1.InputHelper.CheckAccess(key);
            if (!success)
                return errorFunction(message);
            const request = new HttpRequest_1.HttpRequest();
            this.createFetchNewKeyRequest(key, request);
            request.requestType = DataStoreService_1.RequestType.GET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteGet(request)
                .then((r) => {
                const [success, result] = DataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction("Can't parse response");
                const [success2, deserialized] = DataStore.deserializeVariant(result['data'].length === 0 ? '{"d":true}' : result['data'][0]['Value']);
                if (!success2)
                    return errorFunction("Can't parse value");
                this.CachedKeys.set(key, deserialized['d'] ? undefined : deserialized);
                return resumeFunction(deserialized['d'] ? undefined : deserialized);
            })
                .catch((reason) => {
                return errorFunction(reason);
            });
        });
    }
    /**
     *
     * Sets the value of the key.
     * This overwrites any existing data stored in the key.
     *
     * ---
     * CRITICAL
     * --------
     * If the previous value of the key is important,
     * use UpdateAsync() instead.
     * Using GetAsync() to retrieve a value and then setting the key with SetAsync() is risky because GetAsync() sometimes returns cached data and other game servers may have modified the key.
     *
     * ---
     * NOTICE
     * -------
     * Any string being stored in a data store must be valid UTF-8.
     * In UTF-8,
     * values greater than 127 are used exclusively for encoding multi-byte codepoints,
     * so a single byte greater than 127 will not be valid UTF-8 and the SetAsync() attempt will fail.
     *
     * ---
     * If this function throws an error,
     * the error message will describe the problem.
     * Note that there are also limits that apply to this function.
     * See the Data Stores article for an in-depth guide on data structure,
     * management,
     * error handling, etc.
     * @param key The key identifying the entry being retrieved from the data store.
     * @param value The value of the entry in the data store with the given key.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async SetAsync(key, value, userIds = [], options = undefined) {
        return new Promise((resumeFunction, errorFunction) => {
            if (userIds.length > 0)
                return errorFunction('Additional parameter UserIds not allowed');
            if (options)
                return errorFunction('Additional parameter Options not allowed');
            const [success, message] = InputHelper_1.InputHelper.CheckAccess(key);
            if (!success)
                return errorFunction(message);
            if (value === undefined)
                return errorFunction("The value can't be nil, null, undefined or void");
            if (!this.checkValueIsAllowed(value))
                return errorFunction(`${typeof value} is not allowed in ${this.getDataStoreTypeString() === 'standard' ? 'DataStore' : 'OrderedDataStore'}`);
            const [success2, v] = DataStore.serializeVariant(value);
            if (!success2)
                return errorFunction(`${typeof value} is not allowed in ${this.getDataStoreTypeString() === 'standard' ? 'DataStore' : 'OrderedDataStore'}`);
            if (v.length > FastLogTool_1.DFInt('DataStoreMaxValueSize'))
                return errorFunction('Value is too large');
            const request = new HttpRequest_1.HttpRequest();
            request.url = this.constructSetUrl(key, v.length);
            request.owner = this;
            request.key = key;
            request.requestType = DataStoreService_1.RequestType.SET_ASYNC;
            request.postData = `value=${this.urlEncodeIfNeeded(v.toString())}`.toString();
            FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], `[FLog::DataStore] SetAsync on key: %s`, key);
            this.logLongValue(v);
            FastLogTool_1.FASTLOG(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Url encoded:');
            this.logLongValue(request.postData);
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((r) => {
                const [success, res] = DataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction("Can't parse response");
                if (!res['data'])
                    return errorFunction("The response didn't contain the data, therefore a shallow fail was performed");
                if (this.callbacks.has(key)) {
                    this.callbacks.get(key)(value);
                }
                resumeFunction();
            })
                .catch((reason) => {
                return errorFunction(reason);
            });
        });
    }
    /**
     * Increments the value of a particular key and returns the incremented value.
     * Only works on values that are integers.
     * Note that you can use OnUpdate() - Not Implemented - to execute a function every time the database updates the key’s value,
     * such as after calling this function.
     * If this function throws an error,
     * the error message will describe the problem.
     * Note that there are also limits that apply to this function.
     * See the Data Stores article for an in-depth guide on data structure,
     * management,
     * error handling, etc.
     * @param key The key identifying the entry being retrieved from the data store.
     * @param delta The increment amount.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async IncrementAsync(key, delta = 1, userIds = [], options = undefined) {
        return new Promise((resumeFunction, errorFunction) => {
            if (userIds.length > 0)
                return errorFunction('Additional parameter UserIds not allowed');
            if (options)
                return errorFunction('Additional parameter Options not allowed');
            const [success, message] = InputHelper_1.InputHelper.CheckAccess(key);
            if (!success)
                return errorFunction(message);
            const request = new HttpRequest_1.HttpRequest();
            request.url = this.constructIncrementUrl(key, delta);
            request.owner = this;
            request.key = key;
            request.requestType = DataStoreService_1.RequestType.INCREMENT_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((r) => {
                const [success, res] = DataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction("Can't parse response");
                if (!res['data'])
                    return errorFunction('Unable to increment key as it may be anything other than a number');
                if (this.callbacks.has(key)) {
                    this.callbacks.get(key)(parseFloat(res['data']) || 0);
                }
                resumeFunction(parseFloat(res['data']) || 0);
            })
                .catch((reason) => {
                return errorFunction(reason);
            });
        });
    }
    /**
     * Retrieves the value of a key from a data store and updates it with a new value.
     * This function retrieves the value of a key from a data store and updates it with a new value.
     * Since this function validates the data,
     * it should be used in favor of SetAsync() when there’s a chance that more than one server can edit the same data at the same time.
     * The second parameter is a function which you need to provide.
     * The function takes the key’s old value as input and returns the new value,
     * with these exceptions:
     * - If the key does not exist, the old value passed to the function will be nil.
     * - If the function returns nil, the update is cancelled.
     * The value returned by this function is the new value,
     * returned once the altered data is properly saved.
     *
     * ---
     * INFO
     * -----
     * In cases where another game server updated the key in the short timespan between retrieving the key's current value and setting the key's value,
     * UpdateAsync() will call the function again to ensure that no data is overwritten.
     * The function will be called as many times as needed until the data is saved.
     *
     * ---
     * CRITICAL
     * ---------
     * The function you define as the second parameter of UpdateAsync() cannot yield,
     * so do not include calls like setTimeout().
     *
     * ---
     * NOTICE
     * -------
     * Any string being stored in a data store must be valid UTF-8.
     * In UTF-8,
     * values greater than 127 are used exclusively for encoding multi-byte codepoints,
     * so a single byte greater than 127 will not be valid UTF-8 and the SetAsync() attempt will fail.
     *
     * ---
     * If this function throws an error,
     * the error message will describe the problem.
     * Note that there are also limits that apply to this function.
     * See the Data Stores article for an in-depth guide on data structure,
     * management,
     * error handling, etc.
     * @param key The key identifying the entry being retrieved from the data store.
     * @param transformFunc A function which you need to provide. The function takes the key’s old value as input and returns the new value.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async UpdateAsync(key, transformFunc) {
        return new Promise(async (resumeFunction, errorFunction) => {
            const [success, message] = InputHelper_1.InputHelper.CheckAccess(key);
            if (!success)
                return errorFunction(message);
            FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Updating key %s', key);
            const result = await this.runTransformFunction(key, transformFunc);
            resumeFunction(result);
        });
    }
    /**
     * Removes the given key from the data store and returns the value associated with that key.
     * This function removes the given key from the provided GlobalDataStore and returns the value that was associated with that key.
     * If the key is not found in the data store,
     * this function returns undefined.
     * If this function throws an error,
     * the error message will describe the problem.
     * Note that there are also limits that apply to this function.
     * See the Data Stores article for an in-depth guide on data structure,
     * management,
     * error handling, etc.
     * @param key The key identifying the entry being retrieved from the data store.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async RemoveAsync(key) {
        return new Promise((resumeFunction, errorFunction) => {
            const [success, message] = InputHelper_1.InputHelper.CheckAccess(key);
            if (!success)
                return errorFunction(message);
            const request = new HttpRequest_1.HttpRequest();
            request.url = this.constructRemoveUrl(key);
            request.owner = this;
            request.key = key;
            request.requestType = DataStoreService_1.RequestType.SET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((value) => {
                const [success, res] = DataStore.deserializeVariant(value.data);
                if (!success)
                    return errorFunction("Can't parse response");
                resumeFunction(DataStore.deserializeVariant(res['data'])[1]);
            })
                .catch((e) => {
                return errorFunction(e);
            });
        });
    }
    /**
     * This function sets **callback** as the function to be run any time the value associated with the data store's key changes.
     * Once every minute,
     * OnUpdate polls for changes by other servers.
     * Changes made on the same server will run the function immediately.
     * In other words,
     * functions like IncrementAsync(),
     * SetAsync(),
     * and UpdateAsync() change the key’s value in the data store and will cause the function to run.
     * See the Data Stores article for an in-depth guide on data structure,
     * management,
     * error handling, etc.
     * @param key The key identifying the entry being retrieved from the data store
     * @param callback The function to be executed any time the value associated with **key** is changed
     * @returns {RBXScriptConnection} The connection to the key being tracked for updates
     * @deprecated This function has been deprecated and should not be used in new work. You can use the {@link https://www.npmjs.com/package/@mfd/rbxmessagingservice|Cross Server Messaging Service} to publish and subscribe to topics to receive near real-time updates, completely replacing the need for this function.
     */
    OnUpdate(key, callback) {
        FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Legacy on update callback set for the key %s', key);
        this.callbacks.set(key, callback);
        // const interval = setInterval(async () => {
        // 	const v = await this.GetAsync(key);
        // 	if (v !== this.CachedKeys.get(key)) callback(await this.GetAsync(key));
        // }, 60000);
        const event = new events_1.default.EventEmitter();
        event.on('close', () => {
            this.callbacks.delete(key);
            // interval.unref();
        });
        return new RBXScriptConnection_1.RBXScriptConnection(event);
    }
}
exports.DataStore = DataStore;
