"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStore2 = void 0;
const FastLogTool_1 = require("../Tools/FastLogTool");
const Globals_1 = require("../Util/Globals");
const DataStore_1 = require("./DataStore");
const HttpRequest_1 = require("./HttpRequest");
const crypto_js_1 = __importDefault(require("crypto-js"));
const enc_base64_1 = __importDefault(require("crypto-js/enc-base64"));
const SortDirection_1 = require("../Enumeration/SortDirection");
const ExecutionHelper_1 = require("../Helpers/ExecutionHelper");
const InputHelper_1 = require("../Helpers/InputHelper");
const DataStoreService_1 = require("./Services/DataStoreService");
FastLogTool_1.LOGGROUP('DataStore');
FastLogTool_1.LOGVARIABLE('Debug', 0);
FastLogTool_1.DYNAMIC_FASTINT('DataStoreMaxValueSize');
FastLogTool_1.FASTFLAGVARIABLE('UseTestUniverse', false);
class DataStore2 extends DataStore_1.DataStore {
    constructor(name, scope, legacy) {
        super(name, scope, legacy);
    }
    /**
     * @internal
     */
    static async getUniverseID() {
        return Globals_1.Globals.UniverseID;
    }
    /**
     * @internal
     */
    constuctQueriesForPersistenceObjectV2Url(key) {
        return `?dataStore=${this.nameUrlEncodedIfNeeded.toString()}&objectKey=${this.scopeUrlEncodedIfNeeded.toString()}/${this.urlEncodeIfNeeded(key)}`;
    }
    /**
     * @internal
     */
    async constructPersistenceObjectV2Url(key) {
        const universeId = await DataStore2.getUniverseID();
        return `${this.serviceUrl}${FastLogTool_1.FFlag['UseTestUniverse'] ? 2342098878 : universeId}/datastores/objects/object${this.constuctQueriesForPersistenceObjectV2Url(key)}`;
    }
    /**
     * @internal
     */
    async constructIncrementPersistenceObjectV2Url(key, delta) {
        const universeId = await DataStore2.getUniverseID();
        return `${this.serviceUrl}${FastLogTool_1.FFlag['UseTestUniverse'] ? 2342098878 : universeId}/datastores/objects/object/increment${this.constuctQueriesForPersistenceObjectV2Url(key)}&incrementBy=${delta}`;
    }
    /**
     * @internal
     */
    async constructVersionPersistenceObjectV2Url(key, version) {
        const universeId = await DataStore2.getUniverseID();
        return `${this.serviceUrl}${FastLogTool_1.FFlag['UseTestUniverse'] ? 2342098878 : universeId}/datastores/objects/object${this.constuctQueriesForPersistenceObjectV2Url(key)}&version=${version}`;
    }
    /**
     * @internal
     */
    urlApiPath() {
        return 'v2/persistence';
    }
    /////////////// LEGACY MEMBERS ///////////////
    async GetAsync(key) {
        return new Promise(async (resumeFunction, errorFunction) => {
            FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], `[FLog::DataStore] GetAsync on key %s`, key);
            const [success, message] = InputHelper_1.InputHelper.CheckAccess(key);
            if (!success)
                return errorFunction(message);
            const request = new HttpRequest_1.HttpRequest();
            request.key = key;
            request.owner = this;
            request.method = 'GET';
            request.url = await this.constructPersistenceObjectV2Url(key); // This is an await because Typescript says it is.
            request.requestType = DataStoreService_1.RequestType.GET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteGet(request)
                .then((r) => {
                return resumeFunction(r.data instanceof Object || r.data.length > 0 ? r.data : undefined);
            })
                .catch((reason) => {
                if (reason.response) {
                    if (reason.response.data['errors'][0]['code'] === 11)
                        return resumeFunction(undefined);
                    return errorFunction(reason.response.data['errors'][0]['message']);
                }
                return errorFunction(reason);
            });
        });
    }
    async SetAsync(key, value, userIds = [], options = undefined) {
        return new Promise(async (resumeFunction, errorFunction) => {
            const [success, message] = InputHelper_1.InputHelper.CheckAccess(key);
            if (!success)
                return errorFunction(message);
            if (value === undefined)
                return errorFunction("The value can't be nil, null, undefined or void");
            if (!this.checkValueIsAllowed(value))
                return errorFunction(`${typeof value} is not allowed in ${this.getDataStoreTypeString() === 'standard' ? 'DataStore' : 'OrderedDataStore'}`);
            const [success2, v] = DataStore_1.DataStore.serializeVariant(value);
            if (!success2)
                return errorFunction(`${typeof value} is not allowed in ${this.getDataStoreTypeString() === 'standard' ? 'DataStore' : 'OrderedDataStore'}`);
            if (v.length > FastLogTool_1.DFInt('DataStoreMaxValueSize'))
                return errorFunction('Value is too large');
            const request = new HttpRequest_1.HttpRequest();
            request.url = await this.constructPersistenceObjectV2Url(key);
            request.owner = this;
            request.key = key;
            request.requestType = DataStoreService_1.RequestType.SET_ASYNC;
            request.postData = v.toString();
            request.additionalHeaders['Content-MD5'] = enc_base64_1.default.stringify(crypto_js_1.default.MD5(request.postData));
            request.additionalHeaders['Content-Type'] = '*/*';
            request.additionalHeaders['Roblox-Object-Attributes'] = JSON.stringify(options ? options.GetMetadata() : {});
            request.additionalHeaders['Roblox-Object-UserIds'] = JSON.stringify(userIds);
            FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], `[FLog::DataStore] SetAsync on key: %s`, key);
            this.logLongValue(v);
            /*
            Expected response:
            {
                "version": "OBJECT_VERSION_HERE", // The version of the object
                "deleted": false, // Was the key deleted, only works if DELETE on endpoint
                "contentLength": 0, // The absolute content length
                "createdTime": "VERSION_CREATED_DATE_HERE", // The date that this version was created in an ISO string
                "objectCreatedTime": "OBJECT_CREATED_DATE" // The date thet the key was created.
            }
            */
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((r) => {
                const [success] = DataStore_1.DataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction("Can't parse response");
                if (this.callbacks.has(key)) {
                    this.callbacks.get(key)(value);
                }
                resumeFunction();
            })
                .catch((reason) => {
                return errorFunction(reason);
            });
        });
    }
    async RemoveAsync(key) {
        return new Promise(async (resumeFunction, errorFunction) => {
            const [success, message] = InputHelper_1.InputHelper.CheckAccess(key);
            if (!success)
                return errorFunction(message);
            const request = new HttpRequest_1.HttpRequest();
            request.url = await this.constructPersistenceObjectV2Url(key);
            request.owner = this;
            request.key = key;
            request.method = 'DELETE';
            request.requestType = DataStoreService_1.RequestType.SET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((value) => {
                if (!success)
                    return errorFunction("Can't parse response");
                resumeFunction(DataStore_1.DataStore.deserializeVariant(value.data)[1]);
            })
                .catch((e) => {
                return errorFunction(e);
            });
        });
    }
    async IncrementAsync(key, delta = 1, userIds = [], options = undefined) {
        return new Promise(async (resumeFunction, errorFunction) => {
            if (userIds.length > 0)
                return errorFunction('Additional parameter UserIds not allowed');
            if (options)
                return errorFunction('Additional parameter Options not allowed');
            const [success, message] = InputHelper_1.InputHelper.CheckAccess(key);
            if (!success)
                return errorFunction(message);
            const request = new HttpRequest_1.HttpRequest();
            request.url = await this.constructIncrementPersistenceObjectV2Url(key, delta);
            request.owner = this;
            request.additionalHeaders['Roblox-Object-Attributes'] = JSON.stringify(options ? options.GetMetadata() : {});
            request.additionalHeaders['Roblox-Object-UserIds'] = JSON.stringify(userIds);
            request.key = key;
            request.requestType = DataStoreService_1.RequestType.INCREMENT_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((r) => {
                if (this.callbacks.has(key)) {
                    this.callbacks.get(key)(parseFloat(r.data) || 0);
                }
                resumeFunction(parseFloat(r.data) || 0);
            })
                .catch((reason) => {
                return errorFunction(reason);
            });
        });
    }
    /////////////// NEW MEMBERS ///////////////
    /**
     * Returns the value of the entry in the data store with the given key and version.
     * This function returns the value of the entry in the GlobalDataStore with the given key.
     * If the key does not exist,
     * returns undefined.
     * This function used to cache for about 4 seconds,
     * so you couldn't be sure that it returns the current value saved on the Roblox servers.
     * If this function throws an error,
     * the error message will describe the problem.
     * Note that there are also limits that will soon apply to this function.
     * @param {string} key The key identifying the entry being retrieved from the data store.
     * @param {string} version The version identifying the entry version being retrieved from the data store.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     * @returns {Variant} The value of the entry in the data store with the given key
     */
    async GetVersionAsync(key, version) {
        return new Promise(async (resumeFunction, errorFunction) => {
            FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], `[FLog::DataStore] GetVersionAsync on key %s`, key);
            const [success, message] = InputHelper_1.InputHelper.CheckAccess(key);
            if (!success)
                return errorFunction(message);
            const request = new HttpRequest_1.HttpRequest();
            request.key = key;
            request.owner = this;
            request.method = 'GET';
            request.url = await this.constructVersionPersistenceObjectV2Url(key, version); // This is an await because Typescript says it is.
            request.requestType = DataStoreService_1.RequestType.GET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteGet(request)
                .then((r) => {
                return resumeFunction(r.data instanceof Object || r.data.length > 0 ? r.data : undefined);
            })
                .catch((reason) => {
                if (reason.response) {
                    if (reason.response.data['errors'][0]['code'] === 11)
                        return resumeFunction(undefined);
                    return errorFunction(reason.response.data['errors'][0]['message']);
                }
                return errorFunction(reason);
            });
        });
    }
    async ListKeysAsync(prefix = '', pageSize = 0) { }
    async ListVersionsAsync(key, sortDirection = SortDirection_1.SortDirection.Ascending, minDate = 0, maxDate = 0, pageSize = 0) { }
    async RemoveVersionAsync(key, version) { }
}
exports.DataStore2 = DataStore2;
