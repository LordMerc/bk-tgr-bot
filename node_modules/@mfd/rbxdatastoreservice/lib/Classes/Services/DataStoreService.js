"use strict";
// NOTICE Tag internal members as @internal or pull them out.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStoreService = exports.RequestType = void 0;
const DataStore_1 = require("../DataStore");
const Globals_1 = require("../../Util/Globals");
const OrderedDataStore_1 = require("../OrderedDataStore");
const GetDataStoreOptions_1 = require("../GetDataStoreOptions");
const FastLogTool_1 = require("../../Tools/FastLogTool");
const DataStore2_1 = require("../DataStore2");
const LuaWebService_1 = require("../LuaWebService");
const DataStoreEnumerationPages_1 = require("../DataStoreEnumerationPages");
const ApiDataStoresUrlConstruction_1 = require("../../Constructors/ApiDataStoresUrlConstruction");
const InputHelper_1 = require("../../Helpers/InputHelper");
FastLogTool_1.LOGGROUP('DataStore');
FastLogTool_1.DYNAMIC_FASTFLAGVARIABLE('GetGlobalDataStorePcallFix', false);
FastLogTool_1.DYNAMIC_FASTFLAGVARIABLE('DataStoreLostDataFixEnable', false);
FastLogTool_1.DYNAMIC_FASTFLAGVARIABLE('DataStoresV2Enabled', false);
FastLogTool_1.DYNAMIC_FASTINT('DataStoreKeyLengthLimit');
var RequestType;
(function (RequestType) {
    RequestType[RequestType["GET_ASYNC"] = 5] = "GET_ASYNC";
    RequestType[RequestType["UPDATE_ASYNC"] = 6] = "UPDATE_ASYNC";
    RequestType[RequestType["SET_ASYNC"] = 7] = "SET_ASYNC";
    RequestType[RequestType["INCREMENT_ASYNC"] = 8] = "INCREMENT_ASYNC";
    RequestType[RequestType["GET_SORTED_ASYNC_PAGE"] = 9] = "GET_SORTED_ASYNC_PAGE";
})(RequestType = exports.RequestType || (exports.RequestType = {}));
class DataStoreService {
    /**
     * @internal
     */
    static async checkStudioApiAccess(errorFunction) {
        let lws;
        if ((lws = new LuaWebService_1.LuaWebService()))
            if (!(await lws.IsApiAccessEnabled())) {
                if (errorFunction)
                    errorFunction('Cannot write to DataStore from studio if API access is not enabled. Enable it by going to the Game Settings page.');
                return false;
            }
        return true;
    }
    /**
     * @internal
     */
    static useNewApi(options) {
        if (FastLogTool_1.DFFlag('DataStoresV2Enabled')) {
            if (options instanceof GetDataStoreOptions_1.GetDataStoreOptions) {
                const eF = options.GetExperimentalFeatures();
                const it = eF.get('v1.1');
                if (it && typeof it === 'boolean')
                    if (it === true) {
                        return true;
                    }
                throw new ReferenceError(`Options instance of type ${options.toString()} did not request v1.1 API`);
            }
        }
        else {
            if (options !== undefined && options !== null)
                throw TypeError('Options instance not of type GetDataStoreOptions');
        }
        return false;
    }
    /**
     * @internal
     */
    static getDataStoreInternal(name, scope, legacy, ordered, useNewApi) {
        if (Globals_1.Globals.PlaceID < 1) {
            if (FastLogTool_1.DFFlag('GetGlobalDataStorePcallFix')) {
                throw new Error('Place has to be opened with Edit button to access DataStores');
            }
            console.error('Place has to be opened with Edit button to access DataStores');
            return process.exit(1);
        }
        if (legacy) {
            if (!this.legacyDataStore) {
                FastLogTool_1.FASTLOG(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Creating legacy data store');
                this.legacyDataStore = new DataStore_1.DataStore(name, scope, true);
            }
            return this.legacyDataStore;
        }
        else if (ordered) {
            const key = `${name}-${scope}`;
            const it = this.orderedDataStores.has(key);
            if (it === false) {
                FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Creating data store, name: %s', name);
                const ds = new OrderedDataStore_1.OrderedDataStore(name, scope);
                this.orderedDataStores[key] = ds;
                return ds;
            }
            return this.orderedDataStores[key];
        }
        else {
            const key = `${name}-${scope}`;
            const it = this.dataStores.has(key);
            if (it === false) {
                FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Creating data store, name: %s', name);
                let ds;
                if (!useNewApi) {
                    ds = new DataStore_1.DataStore(name, scope, false);
                }
                else {
                    ds = new DataStore2_1.DataStore2(name, scope, false);
                }
                this.dataStores[key] = ds;
                return ds;
            }
            return this.dataStores[key];
        }
    }
    // private static dataStoreJob: DataStoreJob;
    /**
     * This function returns the default {@link https://developer.roblox.com/en-us/api-reference/class/GlobalDataStore|GlobalDataStore}.
     * If you want to access a specific named data store instead,
     * you should use the {@link https://developer.roblox.com/en-us/api-reference/function/DataStoreService/GetDataStore|GetDataStore()} function.
     * @returns {DataStore} Default {@link https://developer.roblox.com/en-us/api-reference/class/GlobalDataStore|GlobalDataStore} instance
     */
    static GetGlobalDataStore() {
        return this.getDataStoreInternal('', 'u', true, false, false);
    }
    /**
     * This method returns a {@link https://developer.roblox.com/en-us/api-reference/class/GlobalDataStore|GlobalDataStore} by name/scope.
     * Subsequent calls to this method with the same name/scope will return the same object.
     * @param {string} name The name of the {@link https://developer.roblox.com/en-us/api-reference/class/GlobalDataStore|GlobalDataStore} you wish to get.
     * @param {string=} scope The scope of the {@link https://developer.roblox.com/en-us/api-reference/class/GlobalDataStore|GlobalDataStore} you wish to get, global by default
     * @returns {DataStore} {@link https://developer.roblox.com/en-us/api-reference/class/GlobalDataStore|GlobalDataStore}
     */
    static GetDataStore(name, scope = 'global', options = undefined) {
        InputHelper_1.InputHelper.CheckNameAndScope(name, scope);
        return this.getDataStoreInternal(name, scope, false, false, DataStoreService.useNewApi(options));
    }
    /**
     * This method returns an {@link https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore|OrderedDataStore},
     * similar to the way {@link https://developer.roblox.com/en-us/api-reference/function/DataStoreService/GetDataStore|GetDataStore()} does with {@link https://developer.roblox.com/en-us/api-reference/class/GlobalDataStore|GlobalDataStores}.
     * Subsequent calls to this method with the same name/scope will return the same object.
     * @param {string} name The name of the {@link https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore|OrderedDataStore} you wish to get.
     * @param {string=} scope The scope of the {@link https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore|OrderedDataStore} you wish to get, global by default
     * @returns {OrderedDataStore} {@link https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore|OrderedDataStore}
     */
    static GetOrderedDataStore(name, scope = 'global') {
        InputHelper_1.InputHelper.CheckNameAndScope(name, scope);
        return this.getDataStoreInternal(name, scope, false, true, false);
    }
    /**
     * This is a funny method that existed for a while and then was purged. Don't use it, all it does is allow you to fetch a key from an empty scope.
     * @param {string} name The name of the {@link https://developer.roblox.com/en-us/api-reference/class/GlobalDataStore|GlobalDataStore} you wish to get.
     * @param {string} key The key identifying the entry being retrieved from the data store.
     * @returns {Variant} {@link https://developer.roblox.com/en-us/api-reference/data-types|Variant}
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     * @deprecated This function has been deprecated and should not be used in new work.
     */
    static async GetDataFromEmptyScopeDataStoreAsyncTemporary(name, key) {
        return new Promise(async (resumeFunction, errorFunction) => {
            if (!FastLogTool_1.DFFlag['DataStoreLostDataFixEnable']) {
                errorFunction('GetDataFromEmptyScopeDataStoreAsyncTemporary is not enabled');
                return;
            }
            if (name.length == 0) {
                errorFunction("DataStore name can't be empty string");
                return;
            }
            if (name.length > FastLogTool_1.DFInt('DataStoreKeyLengthLimit')) {
                errorFunction('DataStore name is too long');
                return;
            }
            const ds = this.getDataStoreInternal(name, '', false, false, false);
            const value = await ds.GetAsync(key);
            resumeFunction(value);
        });
    }
    /**
     *
     * @param {string} prefix
     * @param {number} pageSize
     * @returns {DataStoreEnumerationPages}
     * @yields This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    static async ListDataStoresAsync(prefix = '', pageSize = 0) {
        return new Promise(async (resumeFunction, errorFunction) => {
            if (!FastLogTool_1.DFFlag('DataStoresV2Enabled')) {
                errorFunction('400: API not supported');
                return;
            }
            if (!DataStoreService.checkStudioApiAccess(errorFunction))
                return;
            const url = ApiDataStoresUrlConstruction_1.ApiDataStoresUrlConstruction.constructListKeysUrl(undefined, Globals_1.Globals.UniverseID, prefix, pageSize);
            const page = new DataStoreEnumerationPages_1.DataStoreEnumerationPages(this, url);
            await page.AdvanceToNextPageAsync();
            return resumeFunction(page);
        });
    }
}
exports.DataStoreService = DataStoreService;
/**
 * @internal
 */
DataStoreService.dataStores = new Map();
/**
 * @internal
 */
DataStoreService.orderedDataStores = new Map();
