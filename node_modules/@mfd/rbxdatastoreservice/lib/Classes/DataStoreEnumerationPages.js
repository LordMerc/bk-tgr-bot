"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStoreEnumerationPages = void 0;
const DataStoreService_1 = require("./Services/DataStoreService");
const HttpRequest_1 = require("./HttpRequest");
const Pages_1 = require("./Pages");
const ExecutionHelper_1 = require("../Helpers/ExecutionHelper");
class DataStoreEnumerationPages extends Pages_1.Pages {
    constructor(dss, requestUrl) {
        super();
        this.dss = dss;
        this.requestUrl = requestUrl;
        this.exclusiveStartKey = '';
    }
    /**
     * @internal
     */
    async FetchNextChunk() {
        return new Promise((resumeFunction, errorFunction) => {
            const request = new HttpRequest_1.HttpRequest();
            const dss = this.dss;
            if (!dss) {
                return errorFunction('DataStoreService no longer exists');
            }
            request.url =
                this.exclusiveStartKey.length === 0
                    ? this.requestUrl
                    : `${this.requestUrl.toString()}&exclusiveStartKey=${this.exclusiveStartKey.toString()}`;
            request.requestType = DataStoreService_1.RequestType.GET_SORTED_ASYNC_PAGE;
            ExecutionHelper_1.ExectionHelper.ExecuteGetSorted(request).then((r) => { });
        });
    }
    /**
     * Iterates to the next page in the pages object,
     * if possible.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async AdvanceToNextPageAsync() {
        return new Promise(async (resumeFunction) => {
            if (this.finished) {
                console.error('No pages to advance to');
                return resumeFunction();
            }
            await this.FetchNextChunk();
            resumeFunction();
        });
    }
}
exports.DataStoreEnumerationPages = DataStoreEnumerationPages;
