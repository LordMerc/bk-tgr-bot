"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthenticationHelper = void 0;
//C:\Users\Asjasx\Git\RbxDataStoreService\src\Helpers\Internal\checkCookieAndPlaceIdInternalAsync.ts
//C:\Users\Asjasx\Git\RbxDataStoreService\src\Helpers\InitAuthenticatedUser.ts
const Constants_1 = require("../Util/Constants");
const axios_1 = __importDefault(require("axios"));
const FastLogTool_1 = require("../Tools/FastLogTool");
const UniversesHelper_1 = require("./UniversesHelper");
const UrlTool_1 = require("../Tools/UrlTool");
const Globals_1 = require("../Util/Globals");
const https_1 = require("https");
FastLogTool_1.LOGVARIABLE('Auth', 0);
FastLogTool_1.DYNAMIC_FASTFLAGVARIABLE('WeCareAboutTheWarning', true);
FastLogTool_1.FASTFLAG('Debug');
class AuthenticationHelper {
    static CheckCookieAndPlaceIdInternalAsync(cookie, placeID) {
        return new Promise((resumeFunction, errorFunction) => {
            if (typeof cookie === 'string' && cookie.length === 0) {
                FastLogTool_1.FASTLOG(FastLogTool_1.FLog['Auth'], '[FLog::Auth] The cookie was empty or was not a string, aborting.');
                return errorFunction("Cookie name can't be empty");
            }
            if (placeID < 1) {
                FastLogTool_1.FASTLOG1(FastLogTool_1.FLog['Auth'], '[FLog::Auth] The placeID was %i when it was expected to be >1', placeID);
                return errorFunction('The placeID is required to at least be >1');
            }
            if (!cookie.match(Constants_1.Constants.CookieWarningCapture) && FastLogTool_1.DFFlag('WeCareAboutTheWarning')) {
                FastLogTool_1.FASTLOG(FastLogTool_1.FLog['Auth'], '[FLog::Auth] The cookie was invalid because it did not contain the warning text.');
                return errorFunction("Cookie isn't valid, it requires the warning text to persistent");
            }
            axios_1.default.request({
                url: UrlTool_1.BaseURL.ConstructServicePathFromSubDomain('users', 'v1/users/authenticated', null, true, false, true),
                method: 'GET',
                headers: {
                    ...Globals_1.Globals.GlobalHeaders(),
                    Cookie: '.ROBLOSECURITY=' + cookie,
                    'Roblox-Place-Id': placeID.toString(),
                },
                httpsAgent: new https_1.Agent({ rejectUnauthorized: !FastLogTool_1.FFlag['Debug'] }),
            })
                .then(async (res) => {
                FastLogTool_1.FASTLOG3(FastLogTool_1.FLog['Auth'], '[FLog::Auth] Our cookie check succeeded for user %s - %s (%d), try validate the place ownership and call the resumeFunction()', res.data['name'], res.data['displayName'], res.data['id']);
                const universeId = await UniversesHelper_1.UniversesHelper.GetUniverseIDFromPlaceID(placeID);
                axios_1.default.request({
                    url: UrlTool_1.BaseURL.ConstructServicePathFromSubDomain('develop', 'v1/universes/multiget/permissions', { ids: [universeId] }, true, false, true),
                    method: 'GET',
                    headers: {
                        ...Globals_1.Globals.GlobalHeaders(),
                        Cookie: '.ROBLOSECURITY=' + cookie,
                        'Roblox-Place-Id': placeID.toString(),
                    },
                    httpsAgent: new https_1.Agent({ rejectUnauthorized: !FastLogTool_1.FFlag['Debug'] }),
                })
                    .then((valid) => {
                    if (!valid.data['data'][0]['canManage'] && !valid.data['data'][0]['canCloudEdit']) {
                        FastLogTool_1.FASTLOG(FastLogTool_1.FLog['Auth'], '[FLog::Auth] Our Place check failed because the user does not have the valid credentials to manage this place, call the errorFunction().');
                        return errorFunction(`You do not have valid permission to manage the place ${placeID}`);
                    }
                    FastLogTool_1.FASTLOG2(FastLogTool_1.FLog['Auth'], '[FLog::Auth] Our Place check succeeded for %d (%d), call the resumeFunctiom()', placeID, universeId);
                    return resumeFunction();
                })
                    .catch((err) => {
                    FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['Auth'], '[FLog::Auth] Our authentication check failed because %s, most likely due to a credential mis-match, call the errorFunction()', err);
                    return errorFunction("Cookie isn't valid, validation threw a " +
                        (err.response ? err.response.status : 0) +
                        ' because ' +
                        (err.response ? err.response.data['errors'][0]['message'] : 'Connection Hang'));
                });
            })
                .catch((err) => {
                FastLogTool_1.FASTLOGS(FastLogTool_1.FLog['Auth'], '[FLog::Auth] Our authentication check failed because %s, most likely due to a credential mis-match, call the errorFunction()', err);
                return errorFunction("Cookie isn't valid, validation threw a " +
                    (err.response ? err.response.status : 0) +
                    ' because ' +
                    (err.response ? err.response.data['errors'][0]['message'] : 'Connection Hang'));
            });
        });
    }
    static async InitAuthenticatedUser(cookie, placeID) {
        FastLogTool_1.FASTLOG1(FastLogTool_1.FLog['Auth'], '[FLog::Auth] Trying to authenticate the user with the placeID %i', placeID);
        await AuthenticationHelper.CheckCookieAndPlaceIdInternalAsync(cookie, placeID);
        Globals_1.Globals.Cookie = cookie;
        Globals_1.Globals.PlaceID = placeID;
    }
}
exports.AuthenticationHelper = AuthenticationHelper;
